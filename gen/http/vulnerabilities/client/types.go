// Code generated by goa v3.2.6, DO NOT EDIT.
//
// vulnerabilities HTTP client types
//
// Command:
// $ goa gen citadel/design

package client

import (
	vulnerabilities "citadel/gen/vulnerabilities"

	goa "goa.design/goa/v3/pkg"
)

// SubmitRequestBody is the type of the "vulnerabilities" service "submit"
// endpoint HTTP request body.
type SubmitRequestBody struct {
	// Title of the vulnerability
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Description of the vulnerability
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// If the vulnerability is exploitable
	Exploitable *bool `form:"exploitable,omitempty" json:"exploitable,omitempty" xml:"exploitable,omitempty"`
	// Severity score of the vulnerability
	CvssScore *float32 `form:"cvss_score,omitempty" json:"cvss_score,omitempty" xml:"cvss_score,omitempty"`
	// If the vulnerability is patchable
	IsPatchable *bool `form:"is_patchable,omitempty" json:"is_patchable,omitempty" xml:"is_patchable,omitempty"`
	// If the vulnerability is upgradeable
	IsUpgradeable *bool `form:"is_upgradeable,omitempty" json:"is_upgradeable,omitempty" xml:"is_upgradeable,omitempty"`
}

// FindResponseBody is the type of the "vulnerabilities" service "find"
// endpoint HTTP response body.
type FindResponseBody struct {
	// Unique ID of the vulnerability
	ID *uint64 `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Title of the vulnerability
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Description of the vulnerability
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// If the vulnerability is exploitable
	Exploitable *bool `form:"exploitable,omitempty" json:"exploitable,omitempty" xml:"exploitable,omitempty"`
	// Severity score of the vulnerability
	CvssScore *float32 `form:"cvss_score,omitempty" json:"cvss_score,omitempty" xml:"cvss_score,omitempty"`
	// If the vulnerability is patchable
	IsPatchable *bool `form:"is_patchable,omitempty" json:"is_patchable,omitempty" xml:"is_patchable,omitempty"`
	// If the vulnerability is upgradeable
	IsUpgradeable *bool `form:"is_upgradeable,omitempty" json:"is_upgradeable,omitempty" xml:"is_upgradeable,omitempty"`
}

// ListResponseBody is the type of the "vulnerabilities" service "list"
// endpoint HTTP response body.
type ListResponseBody []*VulnerabilityResponse

// FindNoMatchResponseBody is the type of the "vulnerabilities" service "find"
// endpoint HTTP response body for the "no_match" error.
type FindNoMatchResponseBody string

// SubmitNoMatchResponseBody is the type of the "vulnerabilities" service
// "submit" endpoint HTTP response body for the "no_match" error.
type SubmitNoMatchResponseBody string

// VulnerabilityResponse is used to define fields on response body types.
type VulnerabilityResponse struct {
	// Unique ID of the vulnerability
	ID *uint64 `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Title of the vulnerability
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Description of the vulnerability
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// If the vulnerability is exploitable
	Exploitable *bool `form:"exploitable,omitempty" json:"exploitable,omitempty" xml:"exploitable,omitempty"`
	// Severity score of the vulnerability
	CvssScore *float32 `form:"cvss_score,omitempty" json:"cvss_score,omitempty" xml:"cvss_score,omitempty"`
	// If the vulnerability is patchable
	IsPatchable *bool `form:"is_patchable,omitempty" json:"is_patchable,omitempty" xml:"is_patchable,omitempty"`
	// If the vulnerability is upgradeable
	IsUpgradeable *bool `form:"is_upgradeable,omitempty" json:"is_upgradeable,omitempty" xml:"is_upgradeable,omitempty"`
}

// NewSubmitRequestBody builds the HTTP request body from the payload of the
// "submit" endpoint of the "vulnerabilities" service.
func NewSubmitRequestBody(p *vulnerabilities.SubmitPayload) *SubmitRequestBody {
	body := &SubmitRequestBody{
		Title:         p.Title,
		Description:   p.Description,
		Exploitable:   p.Exploitable,
		CvssScore:     p.CvssScore,
		IsPatchable:   p.IsPatchable,
		IsUpgradeable: p.IsUpgradeable,
	}
	return body
}

// NewFindVulnerabilityOK builds a "vulnerabilities" service "find" endpoint
// result from a HTTP "OK" response.
func NewFindVulnerabilityOK(body *FindResponseBody) *vulnerabilities.Vulnerability {
	v := &vulnerabilities.Vulnerability{
		ID:            *body.ID,
		Title:         body.Title,
		Description:   body.Description,
		Exploitable:   body.Exploitable,
		CvssScore:     body.CvssScore,
		IsPatchable:   body.IsPatchable,
		IsUpgradeable: body.IsUpgradeable,
	}

	return v
}

// NewFindNoMatch builds a vulnerabilities service find endpoint no_match error.
func NewFindNoMatch(body FindNoMatchResponseBody) vulnerabilities.NoMatch {
	v := vulnerabilities.NoMatch(body)
	return v
}

// NewListVulnerabilityOK builds a "vulnerabilities" service "list" endpoint
// result from a HTTP "OK" response.
func NewListVulnerabilityOK(body []*VulnerabilityResponse) []*vulnerabilities.Vulnerability {
	v := make([]*vulnerabilities.Vulnerability, len(body))
	for i, val := range body {
		v[i] = unmarshalVulnerabilityResponseToVulnerabilitiesVulnerability(val)
	}
	return v
}

// NewSubmitNoMatch builds a vulnerabilities service submit endpoint no_match
// error.
func NewSubmitNoMatch(body SubmitNoMatchResponseBody) vulnerabilities.NoMatch {
	v := vulnerabilities.NoMatch(body)
	return v
}

// ValidateFindResponseBody runs the validations defined on FindResponseBody
func ValidateFindResponseBody(body *FindResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.ID != nil {
		if *body.ID < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.id", *body.ID, 0, true))
		}
	}
	return
}

// ValidateVulnerabilityResponse runs the validations defined on
// VulnerabilityResponse
func ValidateVulnerabilityResponse(body *VulnerabilityResponse) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.ID != nil {
		if *body.ID < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.id", *body.ID, 0, true))
		}
	}
	return
}
