// Code generated by goa v3.2.5, DO NOT EDIT.
//
// vulnerabilities HTTP server types
//
// Command:
// $ goa gen citadel/design

package server

import (
	vulnerabilities "citadel/gen/vulnerabilities"
)

// SubmitRequestBody is the type of the "vulnerabilities" service "submit"
// endpoint HTTP request body.
type SubmitRequestBody struct {
	// Title of the vulnerability
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Description of the vulnerability
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// If the vulnerability is exploitable
	Exploitable *bool `form:"exploitable,omitempty" json:"exploitable,omitempty" xml:"exploitable,omitempty"`
	// Severity score of the vulnerability
	CvssScore *float32 `form:"cvss_score,omitempty" json:"cvss_score,omitempty" xml:"cvss_score,omitempty"`
	// If the vulnerability is patchable
	IsPatchable *bool `form:"is_patchable,omitempty" json:"is_patchable,omitempty" xml:"is_patchable,omitempty"`
	// If the vulnerability is upgradeable
	IsUpgradeable *bool `form:"is_upgradeable,omitempty" json:"is_upgradeable,omitempty" xml:"is_upgradeable,omitempty"`
}

// FindResponseBody is the type of the "vulnerabilities" service "find"
// endpoint HTTP response body.
type FindResponseBody struct {
	// Unique ID of the vulnerability
	ID uint64 `form:"id" json:"id" xml:"id"`
	// Title of the vulnerability
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Description of the vulnerability
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// If the vulnerability is exploitable
	Exploitable *bool `form:"exploitable,omitempty" json:"exploitable,omitempty" xml:"exploitable,omitempty"`
	// Severity score of the vulnerability
	CvssScore *float32 `form:"cvss_score,omitempty" json:"cvss_score,omitempty" xml:"cvss_score,omitempty"`
	// If the vulnerability is patchable
	IsPatchable *bool `form:"is_patchable,omitempty" json:"is_patchable,omitempty" xml:"is_patchable,omitempty"`
	// If the vulnerability is upgradeable
	IsUpgradeable *bool `form:"is_upgradeable,omitempty" json:"is_upgradeable,omitempty" xml:"is_upgradeable,omitempty"`
}

// ListResponseBody is the type of the "vulnerabilities" service "list"
// endpoint HTTP response body.
type ListResponseBody []*VulnerabilityResponse

// FindNoMatchResponseBody is the type of the "vulnerabilities" service "find"
// endpoint HTTP response body for the "no_match" error.
type FindNoMatchResponseBody string

// SubmitNoMatchResponseBody is the type of the "vulnerabilities" service
// "submit" endpoint HTTP response body for the "no_match" error.
type SubmitNoMatchResponseBody string

// VulnerabilityResponse is used to define fields on response body types.
type VulnerabilityResponse struct {
	// Unique ID of the vulnerability
	ID uint64 `form:"id" json:"id" xml:"id"`
	// Title of the vulnerability
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Description of the vulnerability
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// If the vulnerability is exploitable
	Exploitable *bool `form:"exploitable,omitempty" json:"exploitable,omitempty" xml:"exploitable,omitempty"`
	// Severity score of the vulnerability
	CvssScore *float32 `form:"cvss_score,omitempty" json:"cvss_score,omitempty" xml:"cvss_score,omitempty"`
	// If the vulnerability is patchable
	IsPatchable *bool `form:"is_patchable,omitempty" json:"is_patchable,omitempty" xml:"is_patchable,omitempty"`
	// If the vulnerability is upgradeable
	IsUpgradeable *bool `form:"is_upgradeable,omitempty" json:"is_upgradeable,omitempty" xml:"is_upgradeable,omitempty"`
}

// NewFindResponseBody builds the HTTP response body from the result of the
// "find" endpoint of the "vulnerabilities" service.
func NewFindResponseBody(res *vulnerabilities.Vulnerability) *FindResponseBody {
	body := &FindResponseBody{
		ID:            res.ID,
		Title:         res.Title,
		Description:   res.Description,
		Exploitable:   res.Exploitable,
		CvssScore:     res.CvssScore,
		IsPatchable:   res.IsPatchable,
		IsUpgradeable: res.IsUpgradeable,
	}
	return body
}

// NewListResponseBody builds the HTTP response body from the result of the
// "list" endpoint of the "vulnerabilities" service.
func NewListResponseBody(res []*vulnerabilities.Vulnerability) ListResponseBody {
	body := make([]*VulnerabilityResponse, len(res))
	for i, val := range res {
		body[i] = marshalVulnerabilitiesVulnerabilityToVulnerabilityResponse(val)
	}
	return body
}

// NewFindNoMatchResponseBody builds the HTTP response body from the result of
// the "find" endpoint of the "vulnerabilities" service.
func NewFindNoMatchResponseBody(res vulnerabilities.NoMatch) FindNoMatchResponseBody {
	body := FindNoMatchResponseBody(res)
	return body
}

// NewSubmitNoMatchResponseBody builds the HTTP response body from the result
// of the "submit" endpoint of the "vulnerabilities" service.
func NewSubmitNoMatchResponseBody(res vulnerabilities.NoMatch) SubmitNoMatchResponseBody {
	body := SubmitNoMatchResponseBody(res)
	return body
}

// NewFindPayload builds a vulnerabilities service find endpoint payload.
func NewFindPayload(id uint64) *vulnerabilities.FindPayload {
	v := &vulnerabilities.FindPayload{}
	v.ID = id

	return v
}

// NewListLimitPayload builds a vulnerabilities service list endpoint payload.
func NewListLimitPayload(limit *int32) *vulnerabilities.LimitPayload {
	v := &vulnerabilities.LimitPayload{}
	v.Limit = limit

	return v
}

// NewSubmitPayload builds a vulnerabilities service submit endpoint payload.
func NewSubmitPayload(body *SubmitRequestBody) *vulnerabilities.SubmitPayload {
	v := &vulnerabilities.SubmitPayload{
		Title:         body.Title,
		Description:   body.Description,
		Exploitable:   body.Exploitable,
		CvssScore:     body.CvssScore,
		IsPatchable:   body.IsPatchable,
		IsUpgradeable: body.IsUpgradeable,
	}

	return v
}
