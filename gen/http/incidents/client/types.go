// Code generated by goa v3.2.6, DO NOT EDIT.
//
// incidents HTTP client types
//
// Command:
// $ goa gen github.com/brittonhayes/citadel/design

package client

import (
	incidents "github.com/brittonhayes/citadel/gen/incidents"
	goa "goa.design/goa/v3/pkg"
)

// FindResponseBody is the type of the "incidents" service "find" endpoint HTTP
// response body.
type FindResponseBody struct {
	// Unique ID of the incident
	ID *uint64 `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Date the incident occurred
	Date *string `form:"date,omitempty" json:"date,omitempty" xml:"date,omitempty"`
	// Date the incident occurred
	DateClosed *string `form:"date_closed,omitempty" json:"date_closed,omitempty" xml:"date_closed,omitempty"`
	// Permissions associated with incident
	Permissions *string `form:"Permissions,omitempty" json:"Permissions,omitempty" xml:"Permissions,omitempty"`
	// The severity of the incident
	Severity *int `form:"severity,omitempty" json:"severity,omitempty" xml:"severity,omitempty"`
	// The short title of the incident
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The detailed description of the incident
	Summary *string `form:"summary,omitempty" json:"summary,omitempty" xml:"summary,omitempty"`
	// The scope of impact of this incident
	Scope *string `form:"scope,omitempty" json:"scope,omitempty" xml:"scope,omitempty"`
	// What group or individual caused the initial incident
	ResponsibleParty *string `form:"responsible_party,omitempty" json:"responsible_party,omitempty" xml:"responsible_party,omitempty"`
	// A list of the affected customers
	AffectedCustomers []string `form:"affected_customers,omitempty" json:"affected_customers,omitempty" xml:"affected_customers,omitempty"`
	// The original cause of the incident
	RootCause *string `form:"root_cause,omitempty" json:"root_cause,omitempty" xml:"root_cause,omitempty"`
	// The slack channel for incident discussions
	SlackChannel *string `form:"slack_channel,omitempty" json:"slack_channel,omitempty" xml:"slack_channel,omitempty"`
	// When the incident was submitted
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// When the incident was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// ListAllResponseBody is the type of the "incidents" service "list all"
// endpoint HTTP response body.
type ListAllResponseBody []*IncidentResponse

// IncidentResponse is used to define fields on response body types.
type IncidentResponse struct {
	// Unique ID of the incident
	ID *uint64 `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Date the incident occurred
	Date *string `form:"date,omitempty" json:"date,omitempty" xml:"date,omitempty"`
	// Date the incident occurred
	DateClosed *string `form:"date_closed,omitempty" json:"date_closed,omitempty" xml:"date_closed,omitempty"`
	// Permissions associated with incident
	Permissions *string `form:"Permissions,omitempty" json:"Permissions,omitempty" xml:"Permissions,omitempty"`
	// The severity of the incident
	Severity *int `form:"severity,omitempty" json:"severity,omitempty" xml:"severity,omitempty"`
	// The short title of the incident
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The detailed description of the incident
	Summary *string `form:"summary,omitempty" json:"summary,omitempty" xml:"summary,omitempty"`
	// The scope of impact of this incident
	Scope *string `form:"scope,omitempty" json:"scope,omitempty" xml:"scope,omitempty"`
	// What group or individual caused the initial incident
	ResponsibleParty *string `form:"responsible_party,omitempty" json:"responsible_party,omitempty" xml:"responsible_party,omitempty"`
	// A list of the affected customers
	AffectedCustomers []string `form:"affected_customers,omitempty" json:"affected_customers,omitempty" xml:"affected_customers,omitempty"`
	// The original cause of the incident
	RootCause *string `form:"root_cause,omitempty" json:"root_cause,omitempty" xml:"root_cause,omitempty"`
	// The slack channel for incident discussions
	SlackChannel *string `form:"slack_channel,omitempty" json:"slack_channel,omitempty" xml:"slack_channel,omitempty"`
	// When the incident was submitted
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// When the incident was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// NewFindIncidentOK builds a "incidents" service "find" endpoint result from a
// HTTP "OK" response.
func NewFindIncidentOK(body *FindResponseBody) *incidents.Incident {
	v := &incidents.Incident{
		ID:               body.ID,
		Date:             body.Date,
		DateClosed:       body.DateClosed,
		Permissions:      body.Permissions,
		Severity:         body.Severity,
		Title:            body.Title,
		Summary:          body.Summary,
		Scope:            body.Scope,
		ResponsibleParty: body.ResponsibleParty,
		RootCause:        body.RootCause,
		SlackChannel:     body.SlackChannel,
		CreatedAt:        body.CreatedAt,
		UpdatedAt:        body.UpdatedAt,
	}
	if body.AffectedCustomers != nil {
		v.AffectedCustomers = make([]string, len(body.AffectedCustomers))
		for i, val := range body.AffectedCustomers {
			v.AffectedCustomers[i] = val
		}
	}

	return v
}

// NewListAllIncidentOK builds a "incidents" service "list all" endpoint result
// from a HTTP "OK" response.
func NewListAllIncidentOK(body []*IncidentResponse) []*incidents.Incident {
	v := make([]*incidents.Incident, len(body))
	for i, val := range body {
		v[i] = unmarshalIncidentResponseToIncidentsIncident(val)
	}
	return v
}

// ValidateFindResponseBody runs the validations defined on FindResponseBody
func ValidateFindResponseBody(body *FindResponseBody) (err error) {
	if body.ID != nil {
		if *body.ID < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.id", *body.ID, 0, true))
		}
	}
	if body.Date != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.date", *body.Date, goa.FormatDate))
	}
	if body.DateClosed != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.date_closed", *body.DateClosed, goa.FormatDate))
	}
	if body.Permissions != nil {
		if !(*body.Permissions == "admin" || *body.Permissions == "analyst" || *body.Permissions == "guest") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.Permissions", *body.Permissions, []interface{}{"admin", "analyst", "guest"}))
		}
	}
	if body.Severity != nil {
		if !(*body.Severity == 0 || *body.Severity == 1 || *body.Severity == 2 || *body.Severity == 3 || *body.Severity == 4 || *body.Severity == 5) {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.severity", *body.Severity, []interface{}{0, 1, 2, 3, 4, 5}))
		}
	}
	if body.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.created_at", *body.CreatedAt, goa.FormatDateTime))
	}
	if body.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.updated_at", *body.UpdatedAt, goa.FormatDateTime))
	}
	return
}

// ValidateIncidentResponse runs the validations defined on IncidentResponse
func ValidateIncidentResponse(body *IncidentResponse) (err error) {
	if body.ID != nil {
		if *body.ID < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.id", *body.ID, 0, true))
		}
	}
	if body.Date != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.date", *body.Date, goa.FormatDate))
	}
	if body.DateClosed != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.date_closed", *body.DateClosed, goa.FormatDate))
	}
	if body.Permissions != nil {
		if !(*body.Permissions == "admin" || *body.Permissions == "analyst" || *body.Permissions == "guest") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.Permissions", *body.Permissions, []interface{}{"admin", "analyst", "guest"}))
		}
	}
	if body.Severity != nil {
		if !(*body.Severity == 0 || *body.Severity == 1 || *body.Severity == 2 || *body.Severity == 3 || *body.Severity == 4 || *body.Severity == 5) {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.severity", *body.Severity, []interface{}{0, 1, 2, 3, 4, 5}))
		}
	}
	if body.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.created_at", *body.CreatedAt, goa.FormatDateTime))
	}
	if body.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.updated_at", *body.UpdatedAt, goa.FormatDateTime))
	}
	return
}
