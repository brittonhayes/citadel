// Code generated by goa v3.2.6, DO NOT EDIT.
//
// vulnerabilities gRPC server types
//
// Command:
// $ goa gen github.com/brittonhayes/citadel/design

package server

import (
	vulnerabilitiespb "github.com/brittonhayes/citadel/gen/grpc/vulnerabilities/pb"
	vulnerabilities "github.com/brittonhayes/citadel/gen/vulnerabilities"
	goa "goa.design/goa/v3/pkg"
)

// NewFindPayload builds the payload of the "find" endpoint of the
// "vulnerabilities" service from the gRPC request type.
func NewFindPayload(message *vulnerabilitiespb.FindRequest) *vulnerabilities.FindPayload {
	v := &vulnerabilities.FindPayload{
		ID: message.Id,
	}
	return v
}

// NewFindResponse builds the gRPC response type from the result of the "find"
// endpoint of the "vulnerabilities" service.
func NewFindResponse(result *vulnerabilities.Vulnerability) *vulnerabilitiespb.FindResponse {
	message := &vulnerabilitiespb.FindResponse{
		Id: result.ID,
	}
	if result.Title != nil {
		message.Title = *result.Title
	}
	if result.Description != nil {
		message.Description = *result.Description
	}
	if result.Exploitable != nil {
		message.Exploitable = *result.Exploitable
	}
	if result.CvssScore != nil {
		message.CvssScore = *result.CvssScore
	}
	if result.IsPatchable != nil {
		message.IsPatchable = *result.IsPatchable
	}
	if result.IsUpgradeable != nil {
		message.IsUpgradeable = *result.IsUpgradeable
	}
	return message
}

// NewListPayload builds the payload of the "list" endpoint of the
// "vulnerabilities" service from the gRPC request type.
func NewListPayload(message *vulnerabilitiespb.ListRequest) *vulnerabilities.LimitPayload {
	v := &vulnerabilities.LimitPayload{}
	if message.Limit != 0 {
		v.Limit = &message.Limit
	}
	return v
}

// NewListResponse builds the gRPC response type from the result of the "list"
// endpoint of the "vulnerabilities" service.
func NewListResponse(result []*vulnerabilities.Vulnerability) *vulnerabilitiespb.ListResponse {
	message := &vulnerabilitiespb.ListResponse{}
	message.Field = make([]*vulnerabilitiespb.Vulnerability, len(result))
	for i, val := range result {
		message.Field[i] = &vulnerabilitiespb.Vulnerability{
			Id: val.ID,
		}
		if val.Title != nil {
			message.Field[i].Title = *val.Title
		}
		if val.Description != nil {
			message.Field[i].Description = *val.Description
		}
		if val.Exploitable != nil {
			message.Field[i].Exploitable = *val.Exploitable
		}
		if val.CvssScore != nil {
			message.Field[i].CvssScore = *val.CvssScore
		}
		if val.IsPatchable != nil {
			message.Field[i].IsPatchable = *val.IsPatchable
		}
		if val.IsUpgradeable != nil {
			message.Field[i].IsUpgradeable = *val.IsUpgradeable
		}
	}
	return message
}

// ValidateListRequest runs the validations defined on ListRequest.
func ValidateListRequest(message *vulnerabilitiespb.ListRequest) (err error) {
	if message.Limit != 0 {
		if message.Limit < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("message.limit", message.Limit, 0, true))
		}
	}
	if message.Limit != 0 {
		if message.Limit > 1000 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("message.limit", message.Limit, 1000, false))
		}
	}
	return
}
