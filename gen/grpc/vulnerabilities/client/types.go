// Code generated by goa v3.2.6, DO NOT EDIT.
//
// vulnerabilities gRPC client types
//
// Command:
// $ goa gen github.com/brittonhayes/citadel/design

package client

import (
	vulnerabilitiespb "github.com/brittonhayes/citadel/gen/grpc/vulnerabilities/pb"
	vulnerabilities "github.com/brittonhayes/citadel/gen/vulnerabilities"
	goa "goa.design/goa/v3/pkg"
)

// NewFindRequest builds the gRPC request type from the payload of the "find"
// endpoint of the "vulnerabilities" service.
func NewFindRequest(payload *vulnerabilities.FindPayload) *vulnerabilitiespb.FindRequest {
	message := &vulnerabilitiespb.FindRequest{
		Id: payload.ID,
	}
	return message
}

// NewFindResult builds the result type of the "find" endpoint of the
// "vulnerabilities" service from the gRPC response type.
func NewFindResult(message *vulnerabilitiespb.FindResponse) *vulnerabilities.Vulnerability {
	result := &vulnerabilities.Vulnerability{
		ID:            message.Id,
		Exploitable:   &message.Exploitable,
		IsPatchable:   &message.IsPatchable,
		IsUpgradeable: &message.IsUpgradeable,
	}
	if message.Title != "" {
		result.Title = &message.Title
	}
	if message.Description != "" {
		result.Description = &message.Description
	}
	if message.CvssScore != 0 {
		result.CvssScore = &message.CvssScore
	}
	return result
}

// NewListRequest builds the gRPC request type from the payload of the "list"
// endpoint of the "vulnerabilities" service.
func NewListRequest(payload *vulnerabilities.LimitPayload) *vulnerabilitiespb.ListRequest {
	message := &vulnerabilitiespb.ListRequest{}
	if payload.Limit != nil {
		message.Limit = *payload.Limit
	}
	return message
}

// NewListResult builds the result type of the "list" endpoint of the
// "vulnerabilities" service from the gRPC response type.
func NewListResult(message *vulnerabilitiespb.ListResponse) []*vulnerabilities.Vulnerability {
	result := make([]*vulnerabilities.Vulnerability, len(message.Field))
	for i, val := range message.Field {
		result[i] = &vulnerabilities.Vulnerability{
			ID:            val.Id,
			Exploitable:   &val.Exploitable,
			IsPatchable:   &val.IsPatchable,
			IsUpgradeable: &val.IsUpgradeable,
		}
		if val.Title != "" {
			result[i].Title = &val.Title
		}
		if val.Description != "" {
			result[i].Description = &val.Description
		}
		if val.CvssScore != 0 {
			result[i].CvssScore = &val.CvssScore
		}
	}
	return result
}

// ValidateFindResponse runs the validations defined on FindResponse.
func ValidateFindResponse(message *vulnerabilitiespb.FindResponse) (err error) {
	if message.Id < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError("message.id", message.Id, 0, true))
	}
	return
}

// ValidateListResponse runs the validations defined on ListResponse.
func ValidateListResponse(message *vulnerabilitiespb.ListResponse) (err error) {
	for _, e := range message.Field {
		if e != nil {
			if err2 := ValidateVulnerability(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateVulnerability runs the validations defined on Vulnerability.
func ValidateVulnerability(message *vulnerabilitiespb.Vulnerability) (err error) {
	if message.Id < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError("message.id", message.Id, 0, true))
	}
	return
}
